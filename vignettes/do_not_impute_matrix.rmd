---
title: "Masking certain entries from imputation model"
date: "2025-08-14"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
    fig_width: 7
    fig_height: 5
    dpi: 600
vignette: >
  %\VignetteIndexEntry{rCISSVAE Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

There are some cases in which we want to tell CISSVAE not to impute certain missing data entries. For example, we would not want to impute patient biomarker values for collection dates past date of death.

We can use the `do_not_impute_matrix` argument in the `run_cissvae()` function to mask these values. The binary `do_not_impute_matrix` should have the same dimensions as the input dataframe with each cell containing 0 (impute if missing) or 1 (do not impute, even if missing). 

Let's use a simple survival dataset as an example. The mock survival dataset can be found at (insert location here)


```{r setup, echo=FALSE}
library(rCISSVAE)
library(tidyverse)
library(ggplot2)
library(kableExtra)
set.seed(42)

set.seed(42)

make_mock_survival_wide <- function(n_patients = 200,
                                    months = seq(0, 60, by = 6),
                                    death_n = 3,
                                    mcar_pct = 0.30) {      # <- 10% random missingness
  month_suffix <- sprintf("m%02d", months)       # m00, m06, …, m60
  biomarker_cols <- c(
    paste0("biomarker1_", month_suffix),
    paste0("biomarker2_", month_suffix),
    paste0("biomarker3_", month_suffix)
  )

  patient_ids <- sprintf("P%03d", seq_len(n_patients))
  died_ids <- sample(patient_ids, size = death_n, replace = FALSE)

  death_years <- setNames(rep(NA_real_, n_patients), patient_ids)
  death_years[died_ids] <- sample(seq(0.5, 4.5, by = 0.5), size = death_n, replace = TRUE)

  rows <- vector("list", n_patients)

  for (i in seq_len(n_patients)) {
    pid <- patient_ids[i]
    base   <- rnorm(1, 0, 0.5)
    slope1 <- rnorm(1,  0.02, 0.01)
    slope2 <- rnorm(1, -0.01, 0.01)
    slope3 <- rnorm(1,  0.00, 0.01)

    b1 <- base + slope1 * months + rnorm(length(months), sd = 0.15)
    b2 <- base + slope2 * months + rnorm(length(months), sd = 0.15)
    b3 <- base + slope3 * months + rnorm(length(months), sd = 0.15)

    # Censor after death: set post-death biomarker values to NA
    dy <- death_years[pid]
    if (!is.na(dy)) {
      cutoff_month <- dy * 12
      post_idx <- which(months > cutoff_month)
      if (length(post_idx) > 0) {
        b1[post_idx] <- NA_real_
        b2[post_idx] <- NA_real_
        b3[post_idx] <- NA_real_
      }
    }

    row_list <- c(
      list(
        patient_id  = pid,
        death_event = as.integer(!is.na(dy)),
        death_year  = unname(dy)
      ),
      setNames(as.list(b1), paste0("biomarker1_", month_suffix)),
      setNames(as.list(b2), paste0("biomarker2_", month_suffix)),
      setNames(as.list(b3), paste0("biomarker3_", month_suffix))
    )

    rows[[i]] <- as.data.frame(row_list, check.names = FALSE, stringsAsFactors = FALSE)
  }

  df <- do.call(rbind, rows)

  # Ensure types
  num_cols <- setdiff(names(df), "patient_id")
  df[num_cols] <- lapply(df[num_cols], function(x) as.numeric(x))

  # Apply MCAR missingness across biomarker cells only (don’t touch death columns)
  if (mcar_pct > 0) {
    bm <- as.matrix(df[, biomarker_cols, drop = FALSE])
    # candidate indices that are currently observed (non-NA)
    obs_idx <- which(!is.na(bm))
    if (length(obs_idx) > 0) {
      m <- ceiling(mcar_pct * length(bm))        # proportion of ALL biomarker cells
      m <- min(m, length(obs_idx))               # cap at available observed cells
      flip <- sample(obs_idx, size = m, replace = FALSE)
      bm[flip] <- NA_real_
      df[, biomarker_cols] <- bm
    }
  }

  # Final column order
  df <- df[, c("patient_id", "death_event", "death_year", biomarker_cols)]
  df
}

#' Create "do not impute" mask for survival-style wide datasets
#'
#' @param df A wide-form dataframe with patient_id, death_event, death_year,
#'   followed by biomarker columns in the format biomarkerX_mYY.
#' @param biomarker_prefixes Character vector of biomarker name prefixes,
#'   e.g. c("biomarker1","biomarker2","biomarker3").
#' @param months Numeric vector of follow-up months corresponding to suffixes,
#'   e.g. seq(0, 60, by = 6).
#'
#' @return A matrix of 0/1 with the same dimension as the biomarker block
#'   (rows = patients, cols = biomarker columns). 0 = can impute, 1 = do not impute.
#' @export
create_do_not_impute_matrix <- function(df,
                                        biomarker_prefixes = c("biomarker1","biomarker2","biomarker3"),
                                        months = seq(0, 60, by = 6)) {
  # biomarker column names
  month_suffix <- sprintf("m%02d", months)
  biomarker_cols <- as.vector(outer(biomarker_prefixes, month_suffix, paste, sep = "_"))

  # initialize mask for full dataframe (all columns)
  mask <- matrix(0L, nrow = nrow(df), ncol = ncol(df),
                 dimnames = list(df$patient_id, colnames(df)))

  # loop over patients to flag post-death measurements
  for (i in seq_len(nrow(df))) {
    dy <- df$death_year[i]
    if (!is.na(dy)) {
      cutoff_month <- dy * 12
      post_idx <- which(months > cutoff_month)
      if (length(post_idx) > 0) {
        cols_to_mask <- as.vector(outer(biomarker_prefixes,
                                        month_suffix[post_idx],
                                        paste, sep = "_"))
        mask[i, cols_to_mask] <- 1L
      }
    }
  }

  mask
}



mock_df <- make_mock_survival_wide()
```

The mock survival dataset looks like 

```{r}
library(gtsummary)
mock_df %>% 
   tbl_summary() %>%
   as_kable()
```

To create the do_not_impute_matrix, do some things. 


```{r}
dni  = create_do_not_impute_matrix(mock_df) %>% as.data.frame()

colnames(dni) = colnames(mock_df)

dni = dni %>% select(-c("death_event", "death_year"))
mock_df = mock_df %>% select(-c("death_event", "death_year"))
```

Now when we run the run_cissvae function


```{r}
res = run_cissvae(mock_df, index_col = "patient_id", do_not_impute_matrix = dni, leiden_resolution = 0.01, return_clusters = TRUE, return_history = TRUE, val_proportion = 0.5, epochs = 100)
```