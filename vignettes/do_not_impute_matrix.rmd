---
title: "Masking certain entries from imputation model"
date: "2025-08-14"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
    fig_width: 7
    fig_height: 5
    dpi: 600
vignette: >
  %\VignetteIndexEntry{rCISSVAE Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

There are some cases in which we want to tell CISSVAE not to impute certain missing data entries. For example, we would not want to impute patient biomarker values for collection dates past date of death.

We can use the `do_not_impute_matrix` argument in the `run_cissvae()` function to mask these values. The binary `do_not_impute_matrix` should have the same dimensions as the input dataframe with each cell containing 0 (impute if missing) or 1 (do not impute, even if missing). 

Let's use a simple survival dataset as an example. 


```{r setup, echo=FALSE}
library(rCISSVAE)
library(tidyverse)
library(ggplot2)
set.seed(42)

set.seed(42)

make_mock_survival_wide <- function(n_patients = 20,
                                    months = seq(0, 60, by = 6),
                                    death_n = 3) {
  month_suffix <- sprintf("m%02d", months)       # m00, m06, …, m60
  biomarker_cols <- c(
    paste0("biomarker1_", month_suffix),
    paste0("biomarker2_", month_suffix),
    paste0("biomarker3_", month_suffix)
  )

  patient_ids <- sprintf("P%03d", seq_len(n_patients))
  died_ids <- sample(patient_ids, size = death_n, replace = FALSE)

  death_years <- setNames(rep(NA_real_, n_patients), patient_ids)
  death_years[died_ids] <- sample(seq(0.5, 4.5, by = 0.5), size = death_n, replace = TRUE)

  rows <- vector("list", n_patients)

  for (i in seq_len(n_patients)) {
    pid <- patient_ids[i]
    base   <- rnorm(1, 0, 0.5)
    slope1 <- rnorm(1,  0.02, 0.01)
    slope2 <- rnorm(1, -0.01, 0.01)
    slope3 <- rnorm(1,  0.00, 0.01)

    b1 <- base + slope1 * months + rnorm(length(months), sd = 0.15)
    b2 <- base + slope2 * months + rnorm(length(months), sd = 0.15)
    b3 <- base + slope3 * months + rnorm(length(months), sd = 0.15)

    dy <- death_years[pid]
    if (!is.na(dy)) {
      cutoff_month <- dy * 12
      post_idx <- which(months > cutoff_month)
      if (length(post_idx) > 0) {
        b1[post_idx] <- NA_real_
        b2[post_idx] <- NA_real_
        b3[post_idx] <- NA_real_
      }
    }

    # Build a named list → single-row data.frame
    row_list <- c(
      list(
        patient_id  = pid,
        death_event = as.integer(!is.na(dy)),
        death_year  = unname(dy)
      ),
      setNames(as.list(b1), paste0("biomarker1_", month_suffix)),
      setNames(as.list(b2), paste0("biomarker2_", month_suffix)),
      setNames(as.list(b3), paste0("biomarker3_", month_suffix))
    )

    rows[[i]] <- as.data.frame(row_list, check.names = FALSE, stringsAsFactors = FALSE)
  }

  # Bind rows safely (no name mangling)
  df <- do.call(rbind, rows)

  # Ensure types: patient_id is chr; others numeric/integer as intended
  num_cols <- setdiff(names(df), "patient_id")
  df[num_cols] <- lapply(df[num_cols], function(x) as.numeric(x))

  # Order columns deterministically
  df <- df[, c("patient_id", "death_event", "death_year", biomarker_cols)]

  df
}

# Example run:

mock_df <- make_mock_survival_wide()
```